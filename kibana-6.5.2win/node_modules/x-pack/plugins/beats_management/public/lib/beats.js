"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
class BeatsLib {
    constructor(adapter, libs) {
        this.adapter = adapter;
        this.libs = libs;
    }
    async get(id) {
        const beat = await this.adapter.get(id);
        return beat ? (await this.mergeInTags([beat]))[0] : null;
    }
    async getBeatWithToken(enrollmentToken) {
        const beat = await this.adapter.getBeatWithToken(enrollmentToken);
        return beat;
    }
    async getBeatsWithTag(tagId) {
        const beats = await this.adapter.getBeatsWithTag(tagId);
        return await this.mergeInTags(beats);
    }
    async getAll(ESQuery) {
        const beats = await this.adapter.getAll(ESQuery);
        return await this.mergeInTags(beats);
    }
    async update(id, beatData) {
        return await this.adapter.update(id, beatData);
    }
    async removeTagsFromBeats(removals) {
        return await this.adapter.removeTagsFromBeats(removals);
    }
    async assignTagsToBeats(assignments) {
        return await this.adapter.assignTagsToBeats(assignments);
    }
    async mergeInTags(beats) {
        const tagIds = lodash_1.flatten(beats.map(b => b.tags || []));
        const tags = await this.libs.tags.getTagsWithIds(tagIds);
        // TODO the filter should not be needed, if the data gets into a bad state, we should error
        // and inform the user they need to delte the tag, or else we should auto delete it
        const mergedBeats = beats.map(b => ({
            ...b,
            full_tags: (b.tags || []).map(tagId => tags.find(t => t.id === tagId)).filter(t => t),
        }));
        return mergedBeats;
    }
}
exports.BeatsLib = BeatsLib;
