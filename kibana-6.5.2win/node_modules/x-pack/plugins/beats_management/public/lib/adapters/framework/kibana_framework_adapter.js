"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ReactDOM = tslib_1.__importStar(require("react-dom"));
class KibanaFrameworkAdapter {
    constructor(uiModule, management, routes, chrome, XPackInfoProvider) {
        this.rootComponent = null;
        this.setUISettings = (key, value) => {
            this.adapterService.callOrBuffer(({ config }) => {
                config.set(key, value);
            });
        };
        this.render = (component) => {
            this.rootComponent = component;
        };
        this.register = (adapterModule) => {
            const adapter = this;
            this.routes.when(`/management/beats_management/:view?/:id?/:other?/:other2?`, {
                template: '<beats-cm><div id="beatsReactRoot" style="flex-grow: 1; height: 100vh; background: #f5f5f5"></div></beats-cm>',
                controllerAs: 'beatsManagement',
                // tslint:disable-next-line: max-classes-per-file
                controller: class BeatsManagementController {
                    constructor($scope, $route) {
                        $scope.$$postDigest(() => {
                            const elem = document.getElementById('beatsReactRoot');
                            ReactDOM.render(adapter.rootComponent, elem);
                            adapter.manageAngularLifecycle($scope, $route, elem);
                        });
                        $scope.$onInit = () => {
                            $scope.topNavMenu = [];
                        };
                    }
                },
            });
        };
        this.adapterService = new KibanaAdapterServiceProvider();
        this.management = management;
        this.uiModule = uiModule;
        this.routes = routes;
        this.chrome = chrome;
        this.XPackInfoProvider = XPackInfoProvider;
        this.appState = {};
    }
    get baseURLPath() {
        return this.chrome.getBasePath();
    }
    hasValidLicense() {
        if (!this.xpackInfo) {
            return false;
        }
        return this.xpackInfo.get('features.beats_management.licenseValid', false);
    }
    licenseExpired() {
        if (!this.xpackInfo) {
            return false;
        }
        return this.xpackInfo.get('features.beats_management.licenseExpired', false);
    }
    securityEnabled() {
        if (!this.xpackInfo) {
            return false;
        }
        return this.xpackInfo.get('features.beats_management.securityEnabled', false);
    }
    getDefaultUserRoles() {
        if (!this.xpackInfo) {
            return [];
        }
        return this.xpackInfo.get('features.beats_management.defaultUserRoles');
    }
    getCurrentUser() {
        try {
            return this.shieldUser;
        }
        catch (e) {
            return null;
        }
    }
    registerManagementSection(pluginId, displayName, basePath) {
        this.register(this.uiModule);
        this.hookAngular(() => {
            if (this.hasValidLicense()) {
                const registerSection = () => this.management.register(pluginId, {
                    display: 'Beats',
                    icon: 'logoBeats',
                    order: 30,
                });
                const getSection = () => this.management.getSection(pluginId);
                const section = this.management.hasItem(pluginId) ? getSection() : registerSection();
                section.register(pluginId, {
                    visible: true,
                    display: displayName,
                    order: 30,
                    url: `#${basePath}`,
                });
            }
        });
    }
    manageAngularLifecycle($scope, $route, elem) {
        const lastRoute = $route.current;
        const deregister = $scope.$on('$locationChangeSuccess', () => {
            const currentRoute = $route.current;
            // if templates are the same we are on the same route
            if (lastRoute.$$route.template === currentRoute.$$route.template) {
                // this prevents angular from destroying scope
                $route.current = lastRoute;
            }
        });
        $scope.$on('$destroy', () => {
            if (deregister) {
                deregister();
            }
            // manually unmount component when scope is destroyed
            if (elem) {
                ReactDOM.unmountComponentAtNode(elem);
            }
        });
    }
    hookAngular(done) {
        this.chrome.dangerouslyGetActiveInjector().then(async ($injector) => {
            const Private = $injector.get('Private');
            const xpackInfo = Private(this.XPackInfoProvider);
            this.xpackInfo = xpackInfo;
            if (this.securityEnabled()) {
                try {
                    this.shieldUser = await $injector.get('ShieldUser').getCurrent().$promise;
                }
                catch (e) {
                    // errors when security disabled, even though we check first because angular
                }
            }
            done();
        });
    }
}
exports.KibanaFrameworkAdapter = KibanaFrameworkAdapter;
// tslint:disable-next-line: max-classes-per-file
class KibanaAdapterServiceProvider {
    constructor() {
        this.serviceRefs = null;
        this.bufferedCalls = [];
    }
    $get($rootScope, config) {
        this.serviceRefs = {
            config,
            rootScope: $rootScope,
        };
        this.applyBufferedCalls(this.bufferedCalls);
        return this;
    }
    callOrBuffer(serviceCall) {
        if (this.serviceRefs !== null) {
            this.applyBufferedCalls([serviceCall]);
        }
        else {
            this.bufferedCalls.push(serviceCall);
        }
    }
    applyBufferedCalls(bufferedCalls) {
        if (!this.serviceRefs) {
            return;
        }
        this.serviceRefs.rootScope.$apply(() => {
            bufferedCalls.forEach(serviceCall => {
                if (!this.serviceRefs) {
                    return;
                }
                return serviceCall(this.serviceRefs);
            });
        });
    }
}
