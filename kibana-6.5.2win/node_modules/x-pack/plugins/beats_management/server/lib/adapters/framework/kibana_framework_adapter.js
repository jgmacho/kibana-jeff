"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
// @ts-ignore
const boom_1 = tslib_1.__importDefault(require("boom"));
const lodash_1 = require("lodash");
// @ts-ignore
const mirror_plugin_status_1 = require("../../../../../../server/lib/mirror_plugin_status");
const plugin_1 = require("../../../../common/constants/plugin");
const wrap_request_1 = require("../../../utils/wrap_request");
class KibanaBackendFrameworkAdapter {
    constructor(hapiServer) {
        this.internalUser = {
            kind: 'internal',
        };
        this.server = hapiServer;
        if (hapiServer.plugins.kibana) {
            this.version = hapiServer.plugins.kibana.status.plugin.version;
        }
        else {
            this.version = 'unknown';
        }
        this.cryptoHash = null;
        this.validateConfig();
        const xpackMainPlugin = hapiServer.plugins.xpack_main;
        const thisPlugin = hapiServer.plugins.beats_management;
        mirror_plugin_status_1.mirrorPluginStatus(xpackMainPlugin, thisPlugin);
        xpackMainPlugin.status.once('green', () => {
            // Register a function that is called whenever the xpack info changes,
            // to re-compute the license check results for this plugin
            xpackMainPlugin.info
                .feature(plugin_1.PLUGIN.ID)
                .registerLicenseCheckResultsGenerator((xPackInfo) => this.checkLicense(xPackInfo));
        });
    }
    // TODO make base path a constructor level param
    getSetting(settingPath) {
        // TODO type check server properly
        if (settingPath === 'xpack.beats.encryptionKey') {
            // @ts-ignore
            return this.server.config().get(settingPath) || this.cryptoHash;
        }
        // @ts-ignore
        return this.server.config().get(settingPath) || this.cryptoHash;
    }
    exposeStaticDir(urlPath, dir) {
        this.server.route({
            handler: {
                directory: {
                    path: dir,
                },
            },
            method: 'GET',
            path: urlPath,
        });
    }
    registerRoute(route) {
        const hasAny = (roles, requiredRoles) => requiredRoles.some(r => roles.includes(r));
        const wrappedHandler = (licenseRequired, requiredRoles) => async (request, reply) => {
            const xpackMainPlugin = this.server.plugins.xpack_main;
            const licenseCheckResults = xpackMainPlugin.info.feature(plugin_1.PLUGIN.ID).getLicenseCheckResults();
            if (licenseRequired && !licenseCheckResults.licenseValid) {
                reply(boom_1.default.forbidden(licenseCheckResults.message));
            }
            const wrappedRequest = wrap_request_1.wrapRequest(request);
            if (requiredRoles) {
                if (wrappedRequest.user.kind !== 'authenticated') {
                    return reply().code(403);
                }
                wrappedRequest.user = {
                    ...wrappedRequest.user,
                    ...(await this.getUser(request)),
                };
                if (wrappedRequest.user.kind === 'authenticated' &&
                    (!hasAny(wrappedRequest.user.roles, this.getSetting('xpack.beats.defaultUserRoles')) ||
                        !wrappedRequest.user.roles) &&
                    lodash_1.difference(requiredRoles, wrappedRequest.user.roles).length !== 0) {
                    return reply().code(403);
                }
            }
            return route.handler(wrappedRequest, reply);
        };
        this.server.route({
            handler: wrappedHandler(route.licenseRequired || false, route.requiredRoles),
            method: route.method,
            path: route.path,
            config: route.config,
        });
    }
    async getUser(request) {
        try {
            return await this.server.plugins.security.getUser(request);
        }
        catch (e) {
            return null;
        }
    }
    // TODO make key a param
    validateConfig() {
        // @ts-ignore
        const config = this.server.config();
        const encryptionKey = config.get('xpack.beats.encryptionKey');
        if (!encryptionKey) {
            this.server.log('Using a default encryption key for xpack.beats.encryptionKey. It is recommended that you set xpack.beats.encryptionKey in kibana.yml with a unique token');
            this.cryptoHash = 'xpack_beats_default_encryptionKey';
        }
    }
    // TODO this should NOT be in an adapter, break up and move validation to a lib
    checkLicense(xPackInfo) {
        // If, for some reason, we cannot get the license information
        // from Elasticsearch, assume worst case and disable the Logstash pipeline UI
        if (!xPackInfo || !xPackInfo.isAvailable()) {
            return {
                securityEnabled: false,
                licenseValid: false,
                message: 'You cannot manage Beats central management because license information is not available at this time.',
            };
        }
        const VALID_LICENSE_MODES = ['trial', 'standard', 'gold', 'platinum'];
        const isLicenseValid = xPackInfo.license.isOneOf(VALID_LICENSE_MODES);
        const isLicenseActive = xPackInfo.license.isActive();
        const licenseType = xPackInfo.license.getType();
        const isSecurityEnabled = xPackInfo.feature('security').isEnabled();
        // License is not valid
        if (!isLicenseValid) {
            return {
                defaultUserRoles: this.getSetting('xpack.beats.defaultUserRoles'),
                securityEnabled: true,
                licenseValid: false,
                licenseExpired: false,
                message: `Your ${licenseType} license does not support Beats central management features. Please upgrade your license.`,
            };
        }
        // License is valid but not active, we go into a read-only mode.
        if (!isLicenseActive) {
            return {
                defaultUserRoles: this.getSetting('xpack.beats.defaultUserRoles'),
                securityEnabled: true,
                licenseValid: true,
                licenseExpired: true,
                message: `You cannot edit, create, or delete your Beats central management configurations because your ${licenseType} license has expired.`,
            };
        }
        // Security is not enabled in ES
        if (!isSecurityEnabled) {
            const message = 'Security must be enabled in order to use Beats central management features.' +
                ' Please set xpack.security.enabled: true in your elasticsearch.yml.';
            return {
                defaultUserRoles: this.getSetting('xpack.beats.defaultUserRoles'),
                securityEnabled: false,
                licenseValid: true,
                licenseExpired: false,
                message,
            };
        }
        // License is valid and active
        return {
            defaultUserRoles: this.getSetting('xpack.beats.defaultUserRoles'),
            securityEnabled: true,
            licenseValid: true,
            licenseExpired: false,
        };
    }
}
exports.KibanaBackendFrameworkAdapter = KibanaBackendFrameworkAdapter;
