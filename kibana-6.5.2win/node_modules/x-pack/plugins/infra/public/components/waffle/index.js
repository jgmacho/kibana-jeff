"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
const eui_1 = require("@elastic/eui");
const lodash_1 = require("lodash");
const react_1 = tslib_1.__importDefault(require("react"));
const styled_components_1 = tslib_1.__importDefault(require("styled-components"));
const types_1 = require("../../../common/graphql/types");
const type_guards_1 = require("../../containers/waffle/type_guards");
const lib_1 = require("../../lib/lib");
const formatters_1 = require("../../utils/formatters");
const auto_sizer_1 = require("../auto_sizer");
const loading_1 = require("../loading");
const group_of_groups_1 = require("./group_of_groups");
const group_of_nodes_1 = require("./group_of_nodes");
const legend_1 = require("./legend");
const apply_wafflemap_layout_1 = require("./lib/apply_wafflemap_layout");
const METRIC_FORMATTERS = {
    [types_1.InfraMetricType.count]: { formatter: lib_1.InfraFormatterType.number, template: '{{value}}' },
    [types_1.InfraMetricType.cpu]: {
        formatter: lib_1.InfraFormatterType.percent,
        template: '{{value}}',
        bounds: { min: 0, max: 1 },
    },
    [types_1.InfraMetricType.memory]: {
        formatter: lib_1.InfraFormatterType.percent,
        template: '{{value}}',
        bounds: { min: 0, max: 1 },
    },
    [types_1.InfraMetricType.rx]: { formatter: lib_1.InfraFormatterType.bits, template: '{{value}}/s' },
    [types_1.InfraMetricType.tx]: { formatter: lib_1.InfraFormatterType.bits, template: '{{value}}/s' },
    [types_1.InfraMetricType.logRate]: {
        formatter: lib_1.InfraFormatterType.abbreviatedNumber,
        template: '{{value}}/s',
    },
};
const extractValuesFromMap = (groups, values = []) => {
    return groups.reduce((acc, group) => {
        if (type_guards_1.isWaffleMapGroupWithGroups(group)) {
            return acc.concat(extractValuesFromMap(group.groups, values));
        }
        if (type_guards_1.isWaffleMapGroupWithNodes(group)) {
            return acc.concat(group.nodes.map(node => {
                return node.metric.value || 0;
            }));
        }
        return acc;
    }, values);
};
const calculateBoundsFromMap = (map) => {
    const values = extractValuesFromMap(map);
    return { min: lodash_1.min(values), max: lodash_1.max(values) };
};
class Waffle extends react_1.default.Component {
    constructor() {
        super(...arguments);
        // TODO: Change this to a real implimentation using the tickFormatter from the prototype as an example.
        this.formatter = (val) => {
            const { metric } = this.props.options;
            const metricFormatter = lodash_1.get(METRIC_FORMATTERS, metric.type, METRIC_FORMATTERS[types_1.InfraMetricType.count]);
            if (val == null) {
                return '';
            }
            const formatter = formatters_1.createFormatter(metricFormatter.formatter, metricFormatter.template);
            return formatter(val);
        };
        this.handleDrilldown = (filter) => {
            this.props.onDrilldown({
                kind: 'kuery',
                expression: filter,
            });
            return;
        };
        this.renderGroup = (bounds) => (group) => {
            if (type_guards_1.isWaffleMapGroupWithGroups(group)) {
                return (react_1.default.createElement(group_of_groups_1.GroupOfGroups, { onDrilldown: this.handleDrilldown, key: group.id, options: this.props.options, group: group, formatter: this.formatter, bounds: bounds, nodeType: this.props.nodeType }));
            }
            if (type_guards_1.isWaffleMapGroupWithNodes(group)) {
                return (react_1.default.createElement(group_of_nodes_1.GroupOfNodes, { key: group.id, options: this.props.options, group: group, onDrilldown: this.handleDrilldown, formatter: this.formatter, isChild: false, bounds: bounds, nodeType: this.props.nodeType }));
            }
        };
    }
    render() {
        const { loading, map, reload } = this.props;
        if (loading) {
            return react_1.default.createElement(loading_1.InfraLoadingPanel, { height: "100%", width: "100%", text: "Loading data" });
        }
        else if (!loading && map && map.length === 0) {
            return (react_1.default.createElement(CenteredEmptyPrompt, { title: react_1.default.createElement("h2", null, "There is no data to display."), titleSize: "m", body: react_1.default.createElement("p", null, "Try adjusting your time or filter."), actions: react_1.default.createElement(eui_1.EuiButton, { iconType: "refresh", color: "primary", fill: true, onClick: () => {
                        reload();
                    } }, "Check for new data"), "data-test-subj": "noMetricsDataPrompt" }));
        }
        const { metric } = this.props.options;
        const metricFormatter = lodash_1.get(METRIC_FORMATTERS, metric.type, METRIC_FORMATTERS[types_1.InfraMetricType.count]);
        const bounds = (metricFormatter && metricFormatter.bounds) || calculateBoundsFromMap(map);
        return (react_1.default.createElement(auto_sizer_1.AutoSizer, { content: true }, ({ measureRef, content: { width = 0, height = 0 } }) => {
            const groupsWithLayout = apply_wafflemap_layout_1.applyWaffleMapLayout(map, width, height);
            return (react_1.default.createElement(WaffleMapOuterContiner, { innerRef: (el) => measureRef(el), "data-test-subj": "waffleMap" },
                react_1.default.createElement(WaffleMapInnerContainer, null, groupsWithLayout.map(this.renderGroup(bounds))),
                react_1.default.createElement(legend_1.Legend, { formatter: this.formatter, bounds: bounds, legend: this.props.options.legend })));
        }));
    }
}
exports.Waffle = Waffle;
const WaffleMapOuterContiner = styled_components_1.default.div `
  flex: 1 0 0%;
  display: flex;
  justify-content: center;
  flex-direction: column;
  overflow-x: hidden;
  overflow-y: auto;
`;
const WaffleMapInnerContainer = styled_components_1.default.div `
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  align-content: flex-start;
  padding: 10px;
`;
const CenteredEmptyPrompt = styled_components_1.default(eui_1.EuiEmptyPrompt) `
  align-self: center;
`;
