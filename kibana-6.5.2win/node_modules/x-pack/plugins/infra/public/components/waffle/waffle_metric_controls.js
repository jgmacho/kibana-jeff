"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eui_1 = require("@elastic/eui");
const react_1 = tslib_1.__importDefault(require("react"));
const types_1 = require("../../../common/graphql/types");
const OPTIONS = {
    [types_1.InfraNodeType.pod]: [
        { text: 'CPU Usage', value: types_1.InfraMetricType.cpu },
        { text: 'Memory Usage', value: types_1.InfraMetricType.memory },
        { text: 'Inbound Traffic', value: types_1.InfraMetricType.rx },
        { text: 'Outbound Traffic', value: types_1.InfraMetricType.tx },
    ],
    [types_1.InfraNodeType.container]: [
        { text: 'CPU Usage', value: types_1.InfraMetricType.cpu },
        { text: 'Memory Usage', value: types_1.InfraMetricType.memory },
        { text: 'Inbound Traffic', value: types_1.InfraMetricType.rx },
        { text: 'Outbound Traffic', value: types_1.InfraMetricType.tx },
    ],
    [types_1.InfraNodeType.host]: [
        { text: 'CPU Usage', value: types_1.InfraMetricType.cpu },
        { text: 'Memory Usage', value: types_1.InfraMetricType.memory },
        { text: 'Load', value: types_1.InfraMetricType.load },
        { text: 'Inbound Traffic', value: types_1.InfraMetricType.rx },
        { text: 'Outbound Traffic', value: types_1.InfraMetricType.tx },
        { text: 'Log Rate', value: types_1.InfraMetricType.logRate },
    ],
};
const initialState = {
    isPopoverOpen: false,
};
class WaffleMetricControls extends react_1.default.PureComponent {
    constructor() {
        super(...arguments);
        this.state = initialState;
        this.handleClose = () => {
            this.setState({ isPopoverOpen: false });
        };
        this.handleToggle = () => {
            this.setState(state => ({ isPopoverOpen: !state.isPopoverOpen }));
        };
        this.handleClick = (value) => () => {
            this.props.onChange({ type: value });
            this.handleClose();
        };
    }
    render() {
        const { metric } = this.props;
        const options = OPTIONS[this.props.nodeType];
        const value = metric.type;
        if (!options.length || !value) {
            throw Error('Unable to select options or value for metric.');
        }
        const currentLabel = options.find(o => o.value === metric.type);
        if (!currentLabel) {
            return 'null';
        }
        const panels = [
            {
                id: 0,
                title: '',
                items: options.map(o => {
                    const icon = o.value === metric.type ? 'check' : 'empty';
                    const panel = { name: o.text, onClick: this.handleClick(o.value), icon };
                    return panel;
                }),
            },
        ];
        const button = (react_1.default.createElement(eui_1.EuiFilterButton, { iconType: "arrowDown", onClick: this.handleToggle },
            "Metric: ",
            currentLabel.text));
        return (react_1.default.createElement(eui_1.EuiFilterGroup, null,
            react_1.default.createElement(eui_1.EuiPopover, { isOpen: this.state.isPopoverOpen, id: "metricsPanel", button: button, panelPaddingSize: "none", closePopover: this.handleClose },
                react_1.default.createElement(eui_1.EuiContextMenu, { initialPanelId: 0, panels: panels }))));
    }
}
exports.WaffleMetricControls = WaffleMetricControls;
