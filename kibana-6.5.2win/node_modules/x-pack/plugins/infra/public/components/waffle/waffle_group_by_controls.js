"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eui_1 = require("@elastic/eui");
const react_1 = tslib_1.__importDefault(require("react"));
const types_1 = require("../../../common/graphql/types");
const OPTIONS = {
    [types_1.InfraNodeType.pod]: [
        { text: 'Namespace', type: types_1.InfraPathType.terms, field: 'kubernetes.namespace' },
        { text: 'Node', type: types_1.InfraPathType.terms, field: 'kubernetes.node.name' },
    ],
    [types_1.InfraNodeType.container]: [
        { text: 'Host', type: types_1.InfraPathType.terms, field: 'host.name' },
        { text: 'Availability Zone', type: types_1.InfraPathType.terms, field: 'meta.cloud.availability_zone' },
        { text: 'Machine Type', type: types_1.InfraPathType.terms, field: 'meta.cloud.machine_type' },
        { text: 'Project ID', type: types_1.InfraPathType.terms, field: 'meta.cloud.project_id' },
        { text: 'Provider', type: types_1.InfraPathType.terms, field: 'meta.cloud.provider' },
    ],
    [types_1.InfraNodeType.host]: [
        { text: 'Availability Zone', type: types_1.InfraPathType.terms, field: 'meta.cloud.availability_zone' },
        { text: 'Machine Type', type: types_1.InfraPathType.terms, field: 'meta.cloud.machine_type' },
        { text: 'Project ID', type: types_1.InfraPathType.terms, field: 'meta.cloud.project_id' },
        { text: 'Cloud Provider', type: types_1.InfraPathType.terms, field: 'meta.cloud.provider' },
    ],
};
const initialState = {
    isPopoverOpen: false,
};
class WaffleGroupByControls extends react_1.default.PureComponent {
    constructor() {
        super(...arguments);
        this.state = initialState;
        this.handleRemove = (field) => () => {
            const { groupBy } = this.props;
            this.props.onChange(groupBy.filter(g => g.field !== field));
            // We need to close the panel after we rmeove the pill icon otherwise
            // it will remain open because the click is still captured by the EuiFilterButton
            setTimeout(() => this.handleClose());
        };
        this.handleClose = () => {
            this.setState({ isPopoverOpen: false });
        };
        this.handleToggle = () => {
            this.setState(state => ({ isPopoverOpen: !state.isPopoverOpen }));
        };
        this.handleClick = (field) => () => {
            const { groupBy } = this.props;
            if (groupBy.some(g => g.field === field)) {
                this.handleRemove(field)();
            }
            else if (this.props.groupBy.length < 2) {
                this.props.onChange([...groupBy, { type: types_1.InfraPathType.terms, field }]);
                this.handleClose();
            }
        };
    }
    render() {
        const { nodeType, groupBy } = this.props;
        const options = OPTIONS[nodeType];
        if (!options.length) {
            throw Error(`Unable to select group by options for ${nodeType}`);
        }
        const panels = [
            {
                id: 'firstPanel',
                title: 'Select up to two groupings',
                items: options.map(o => {
                    const icon = groupBy.some(g => g.field === o.field) ? 'check' : 'empty';
                    const panel = { name: o.text, onClick: this.handleClick(o.field), icon };
                    return panel;
                }),
            },
        ];
        const buttonBody = groupBy.length > 0
            ? groupBy
                .map(g => options.find(o => o.field === g.field))
                .filter(o => o != null)
                // In this map the `o && o.field` is totally unnecessary but Typescript is
                // too stupid to realize that the filter above prevents the next map from being null
                .map(o => (react_1.default.createElement(eui_1.EuiBadge, { key: o && o.field, iconType: "cross", iconOnClick: this.handleRemove((o && o.field) || ''), iconOnClickAriaLabel: `Remove ${o && o.text} grouping` }, o && o.text)))
            : 'All';
        const button = (react_1.default.createElement(eui_1.EuiFilterButton, { iconType: "arrowDown", onClick: this.handleToggle },
            "Group By: ",
            buttonBody));
        return (react_1.default.createElement(eui_1.EuiFilterGroup, null,
            react_1.default.createElement(eui_1.EuiPopover, { isOpen: this.state.isPopoverOpen, id: "groupByPanel", button: button, panelPaddingSize: "none", closePopover: this.handleClose },
                react_1.default.createElement(eui_1.EuiContextMenu, { initialPanelId: "firstPanel", panels: panels }))));
    }
}
exports.WaffleGroupByControls = WaffleGroupByControls;
