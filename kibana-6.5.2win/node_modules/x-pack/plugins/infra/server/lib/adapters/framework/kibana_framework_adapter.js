"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const adapter_types_1 = require("./adapter_types");
const apollo_server_hapi_1 = require("./apollo_server_hapi");
class InfraKibanaBackendFrameworkAdapter {
    constructor(hapiServer) {
        this.server = hapiServer;
        this.version = hapiServer.plugins.kibana.status.plugin.version;
    }
    exposeStaticDir(urlPath, dir) {
        this.server.route({
            handler: {
                directory: {
                    path: dir,
                },
            },
            method: 'GET',
            path: urlPath,
        });
    }
    registerGraphQLEndpoint(routePath, schema) {
        this.server.register({
            options: {
                graphqlOptions: (req) => ({
                    context: { req: wrapRequest(req) },
                    schema,
                }),
                path: routePath,
            },
            register: apollo_server_hapi_1.graphqlHapi,
        });
        this.server.register({
            options: {
                graphiqlOptions: {
                    endpointURL: routePath,
                    passHeader: `'kbn-version': '${this.version}'`,
                },
                path: `${routePath}/graphiql`,
            },
            register: apollo_server_hapi_1.graphiqlHapi,
        });
    }
    registerRoute(route) {
        const wrappedHandler = (request, reply) => route.handler(wrapRequest(request), reply);
        this.server.route({
            handler: wrappedHandler,
            method: route.method,
            path: route.path,
        });
    }
    async callWithRequest(req, ...rest) {
        const internalRequest = req[adapter_types_1.internalInfraFrameworkRequest];
        const { elasticsearch } = internalRequest.server.plugins;
        const { callWithRequest } = elasticsearch.getCluster('data');
        const fields = await callWithRequest(internalRequest, ...rest);
        return fields;
    }
    getIndexPatternsService(request) {
        if (!isServerWithIndexPatternsServiceFactory(this.server)) {
            throw new Error('Failed to access indexPatternsService for the request');
        }
        return this.server.indexPatternsServiceFactory({
            callCluster: async (method, args, ...rest) => {
                const fieldCaps = await this.callWithRequest(request, method, { ...args, allowNoIndices: true }, ...rest);
                return fieldCaps;
            },
        });
    }
    async makeTSVBRequest(req, model, timerange, filters) {
        const internalRequest = req[adapter_types_1.internalInfraFrameworkRequest];
        const server = internalRequest.server;
        return new Promise((resolve, reject) => {
            const request = {
                url: '/api/metrics/vis/data',
                method: 'POST',
                headers: internalRequest.headers,
                payload: {
                    timerange,
                    panels: [model],
                    filters,
                },
            };
            server.inject(request, res => {
                if (res.statusCode !== 200) {
                    return reject(res);
                }
                resolve(res.result);
            });
        });
    }
}
exports.InfraKibanaBackendFrameworkAdapter = InfraKibanaBackendFrameworkAdapter;
function wrapRequest(req) {
    const { params, payload, query } = req;
    return {
        [adapter_types_1.internalInfraFrameworkRequest]: req,
        params,
        payload,
        query,
    };
}
exports.wrapRequest = wrapRequest;
const isServerWithIndexPatternsServiceFactory = (server) => typeof server.indexPatternsServiceFactory === 'function';
