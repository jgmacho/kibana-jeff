"use strict";
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License;
 * you may not use this file except in compliance with the Elastic License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const moment_1 = tslib_1.__importDefault(require("moment"));
const react_1 = tslib_1.__importStar(require("react"));
const chrome_1 = tslib_1.__importDefault(require("ui/chrome"));
const notify_1 = require("ui/notify");
const poller_1 = require("../../../../common/poller");
const download_report_1 = require("../lib/download_report");
const job_queue_client_1 = require("../lib/job_queue_client");
const report_error_button_1 = require("./report_error_button");
const eui_1 = require("@elastic/eui");
class ReportListing extends react_1.Component {
    constructor(props) {
        super(props);
        this.renderDownloadButton = (record) => {
            if (record.status !== 'completed') {
                return;
            }
            const button = (react_1.default.createElement(eui_1.EuiButtonIcon, { onClick: () => download_report_1.downloadReport(record.id), iconType: "importAction", "aria-label": "Download report" }));
            if (record.max_size_reached) {
                return (react_1.default.createElement(eui_1.EuiToolTip, { position: "top", content: "Max size reached, contains partial data." }, button));
            }
            return button;
        };
        this.renderReportErrorButton = (record) => {
            if (record.status !== 'failed') {
                return;
            }
            return react_1.default.createElement(report_error_button_1.ReportErrorButton, { jobId: record.id });
        };
        this.onTableChange = ({ page }) => {
            const { index: pageIndex } = page;
            this.setState({
                page: pageIndex,
            }, this.fetchJobs);
        };
        this.fetchJobs = async () => {
            // avoid page flicker when poller is updating table - only display loading screen on first load
            if (this.isInitialJobsFetch) {
                this.setState({ isLoading: true });
            }
            let jobs;
            let total;
            try {
                jobs = await job_queue_client_1.jobQueueClient.list(this.state.page);
                total = await job_queue_client_1.jobQueueClient.total();
                this.isInitialJobsFetch = false;
            }
            catch (kfetchError) {
                if (!this.licenseAllowsToShowThisPage()) {
                    notify_1.toastNotifications.addDanger(this.props.badLicenseMessage);
                    this.props.redirect('/management');
                    return;
                }
                if (kfetchError.res.status !== 401 && kfetchError.res.status !== 403) {
                    notify_1.toastNotifications.addDanger(kfetchError.res.statusText || 'Request failed');
                }
                if (this.mounted) {
                    this.setState({ isLoading: false, jobs: [], total: 0 });
                }
                return;
            }
            if (this.mounted) {
                this.setState({
                    isLoading: false,
                    total,
                    jobs: jobs.map((job) => {
                        return {
                            id: job._id,
                            type: job._source.jobtype,
                            object_type: job._source.payload.type,
                            object_title: job._source.payload.title,
                            created_by: job._source.created_by,
                            created_at: job._source.created_at,
                            started_at: job._source.started_at,
                            completed_at: job._source.completed_at,
                            status: job._source.status,
                            max_size_reached: job._source.output ? job._source.output.max_size_reached : false,
                        };
                    }),
                });
            }
        };
        this.licenseAllowsToShowThisPage = () => {
            return this.props.showLinks && this.props.enableLinks;
        };
        this.state = {
            page: 0,
            total: 0,
            jobs: [],
            isLoading: false,
        };
        this.isInitialJobsFetch = true;
    }
    render() {
        return (react_1.default.createElement(eui_1.EuiPage, null,
            react_1.default.createElement(eui_1.EuiPageBody, { restrictWidth: true },
                react_1.default.createElement(eui_1.EuiPageContent, { horizontalPosition: "center" },
                    react_1.default.createElement(eui_1.EuiTitle, null,
                        react_1.default.createElement("h1", null, "Reports")),
                    this.renderTable()))));
    }
    componentWillUnmount() {
        this.mounted = false;
        this.poller.stop();
    }
    componentDidMount() {
        this.mounted = true;
        const { jobsRefresh } = chrome_1.default.getInjected('reportingPollConfig');
        this.poller = new poller_1.Poller({
            functionToPoll: () => {
                return this.fetchJobs();
            },
            pollFrequencyInMillis: jobsRefresh.interval,
            trailing: false,
            continuePollingOnError: true,
            pollFrequencyErrorMultiplier: jobsRefresh.intervalErrorMultiplier,
        });
        this.poller.start();
    }
    renderTable() {
        const tableColumns = [
            {
                field: 'object_title',
                name: 'Report',
                render: (objectTitle, record) => {
                    return (react_1.default.createElement("div", null,
                        react_1.default.createElement("div", null, objectTitle),
                        react_1.default.createElement(eui_1.EuiText, { size: "s" },
                            react_1.default.createElement(eui_1.EuiTextColor, { color: "subdued" }, record.object_type))));
                },
            },
            {
                field: 'created_at',
                name: 'Created at',
                render: (createdAt, record) => {
                    if (record.created_by) {
                        return (react_1.default.createElement("div", null,
                            react_1.default.createElement("div", null, this.formatDate(createdAt)),
                            react_1.default.createElement("span", null, record.created_by)));
                    }
                    return this.formatDate(createdAt);
                },
            },
            {
                field: 'status',
                name: 'Status',
                render: (status, record) => {
                    if (status === 'pending') {
                        return react_1.default.createElement("div", null, "pending - waiting for job to be processed");
                    }
                    let maxSizeReached;
                    if (record.max_size_reached) {
                        maxSizeReached = react_1.default.createElement("span", null, " - max size reached");
                    }
                    let statusTimestamp;
                    if (status === 'processing' && record.started_at) {
                        statusTimestamp = this.formatDate(record.started_at);
                    }
                    else if (record.completed_at && (status === 'completed' || status === 'failed')) {
                        statusTimestamp = this.formatDate(record.completed_at);
                    }
                    if (statusTimestamp) {
                        return (react_1.default.createElement("div", null,
                            status,
                            ' at ',
                            react_1.default.createElement("span", { className: "eui-textNoWrap" }, statusTimestamp),
                            maxSizeReached));
                    }
                    // unknown status
                    return (react_1.default.createElement("div", null,
                        status,
                        maxSizeReached));
                },
            },
            {
                name: 'Actions',
                actions: [
                    {
                        render: (record) => {
                            return (react_1.default.createElement("div", null,
                                this.renderDownloadButton(record),
                                this.renderReportErrorButton(record)));
                        },
                    },
                ],
            },
        ];
        const pagination = {
            pageIndex: this.state.page,
            pageSize: 10,
            totalItemCount: this.state.total,
            hidePerPageOptions: true,
        };
        return (react_1.default.createElement(eui_1.EuiBasicTable, { itemId: 'id', items: this.state.jobs, loading: this.state.isLoading, columns: tableColumns, noItemsMessage: this.state.isLoading ? 'Loading reports' : 'No reports have been created', pagination: pagination, onChange: this.onTableChange }));
    }
    formatDate(timestamp) {
        try {
            return moment_1.default(timestamp).format('YYYY-MM-DD @ hh:mm A');
        }
        catch (error) {
            // ignore parse error and display unformatted value
            return timestamp;
        }
    }
}
exports.ReportListing = ReportListing;
