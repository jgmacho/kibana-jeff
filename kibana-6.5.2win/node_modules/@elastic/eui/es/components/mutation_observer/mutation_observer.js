import "core-js/modules/es7.symbol.async-iterator";
import "core-js/modules/es6.symbol";
import "core-js/modules/web.dom.iterable";
import "core-js/modules/es6.array.iterator";
import "core-js/modules/es6.object.keys";
import "core-js/modules/es6.object.set-prototype-of";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import PropTypes from 'prop-types';
/**
 * EuiMutationObserver watches its children with the MutationObserver API
 * There are a couple constraints which inform how this component works
 *
 * 1. React refs cannot be added to functional components
 * 2. findDOMNode will only return the first element from an array of children
 *    or from a fragment.
 *
 * Because of #1, we can't blindly attach refs to children and expect them to work in all cases
 * Because of #2, we can't observe all children for mutations, only the first
 *
 * When only one child is passed its found by findDOMNode and the mutation observer is attached
 * When children is an array the render function maps over them wrapping each child
 *   with another EuiMutationObserver, e.g.:
 *
 *   <Observer>
 *     <div>First</div>
 *     <div>Second</div>
 *   </Observer>
 *
 *   becomes
 *
 *   <Observer>
 *     <Observer><div>First</div></Observer>
 *     <Observer><div>Second</div></Observer>
 *   </Observer>
 *
 *   each descendant-Observer has only one child and can independently watch for mutations,
 *   triggering the parent's onMutation callback when an event is observed
 */

var EuiMutationObserver =
/*#__PURE__*/
function (_Component) {
  _inherits(EuiMutationObserver, _Component);

  function EuiMutationObserver() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, EuiMutationObserver);

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EuiMutationObserver)).call.apply(_getPrototypeOf2, [this].concat(_args)));

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "onMutation", function () {
      var _this$props;

      (_this$props = _this.props).onMutation.apply(_this$props, arguments);
    });

    _this.childNode = null;
    _this.observer = null;
    return _this;
  }

  _createClass(EuiMutationObserver, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateChildNode();
    }
  }, {
    key: "updateChildNode",
    value: function updateChildNode() {
      if (Array.isArray(this.props.children) === false) {
        var currentNode = findDOMNode(this);

        if (this.childNode !== currentNode) {
          // if there's an existing observer disconnect it
          if (this.observer != null) {
            this.observer.disconnect();
            this.observer = null;
          }

          this.childNode = currentNode;

          if (this.childNode != null) {
            this.observer = new MutationObserver(this.onMutation);
            this.observer.observe(this.childNode, this.props.observerOptions);
          }
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      // in case the child element was changed
      this.updateChildNode();
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          children = _this$props2.children,
          rest = _objectWithoutProperties(_this$props2, ["children"]);

      if (Array.isArray(children)) {
        return React.Children.map(children, function (child) {
          return React.createElement(EuiMutationObserver, rest, child);
        });
      } else {
        return children;
      }
    }
  }]);

  return EuiMutationObserver;
}(Component);

EuiMutationObserver.propTypes = {
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.arrayOf(PropTypes.node)]),
  observerOptions: PropTypes.shape({
    // matches a [MutationObserverInit](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserverInit)
    attributeFilter: PropTypes.arrayOf(PropTypes.string),
    attributeOldValue: PropTypes.bool,
    attributes: PropTypes.bool,
    characterData: PropTypes.bool,
    characterDataOldValue: PropTypes.bool,
    childList: PropTypes.bool,
    subtree: PropTypes.bool
  }).isRequired,
  onMutation: PropTypes.func.isRequired
};
export { EuiMutationObserver };
EuiMutationObserver.__docgenInfo = {
  "description": "EuiMutationObserver watches its children with the MutationObserver API\nThere are a couple constraints which inform how this component works\n\n1. React refs cannot be added to functional components\n2. findDOMNode will only return the first element from an array of children\n   or from a fragment.\n\nBecause of #1, we can't blindly attach refs to children and expect them to work in all cases\nBecause of #2, we can't observe all children for mutations, only the first\n\nWhen only one child is passed its found by findDOMNode and the mutation observer is attached\nWhen children is an array the render function maps over them wrapping each child\n  with another EuiMutationObserver, e.g.:\n\n  <Observer>\n    <div>First</div>\n    <div>Second</div>\n  </Observer>\n\n  becomes\n\n  <Observer>\n    <Observer><div>First</div></Observer>\n    <Observer><div>Second</div></Observer>\n  </Observer>\n\n  each descendant-Observer has only one child and can independently watch for mutations,\n  triggering the parent's onMutation callback when an event is observed",
  "methods": [{
    "name": "updateChildNode",
    "docblock": null,
    "modifiers": [],
    "params": [],
    "returns": null
  }, {
    "name": "onMutation",
    "docblock": null,
    "modifiers": [],
    "params": [{
      "name": "...args",
      "type": null
    }],
    "returns": null
  }],
  "displayName": "EuiMutationObserver",
  "props": {
    "children": {
      "type": {
        "name": "union",
        "value": [{
          "name": "node"
        }, {
          "name": "arrayOf",
          "value": {
            "name": "node"
          }
        }]
      },
      "required": false,
      "description": ""
    },
    "observerOptions": {
      "type": {
        "name": "shape",
        "value": {
          "attributeFilter": {
            "name": "arrayOf",
            "value": {
              "name": "string"
            },
            "required": false
          },
          "attributeOldValue": {
            "name": "bool",
            "required": false
          },
          "attributes": {
            "name": "bool",
            "required": false
          },
          "characterData": {
            "name": "bool",
            "required": false
          },
          "characterDataOldValue": {
            "name": "bool",
            "required": false
          },
          "childList": {
            "name": "bool",
            "required": false
          },
          "subtree": {
            "name": "bool",
            "required": false
          }
        }
      },
      "required": true,
      "description": ""
    },
    "onMutation": {
      "type": {
        "name": "func"
      },
      "required": true,
      "description": ""
    }
  }
};